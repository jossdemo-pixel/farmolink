
-- ============================================================================
-- 🏥 FARMOLINK PROD v1.6 - SCRIPT MESTRE DEFINITIVO E COMPLETO
-- Foco: Integridade de Schema, Segurança (RLS), Notificações e Financeiro robusto.
-- UPDATE v1.6: Hardening financeiro idempotente, normalizacao robusta de status e liquidação por periodo.
-- ============================================================================

-- 1. CONFIGURAÇÃO INICIAL E EXTENSÕES
CREATE EXTENSION IF NOT EXISTS "pg_trgm"; -- Para buscas rápidas (Fuzzy Search)
CREATE EXTENSION IF NOT EXISTS "pgcrypto"; -- Necessário para gen_random_uuid()

-- 2. TABELAS CORE (ESTRUTURA COMPLETA)

-- Configuração do Sistema (Carrossel, Banners)
CREATE TABLE IF NOT EXISTS public.carousel_slides (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    title TEXT NOT NULL,
    subtitle TEXT,
    image_url TEXT NOT NULL,
    button_text TEXT DEFAULT 'SABER MAIS',
    "order" INTEGER DEFAULT 1,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Parceiros e Marcas
CREATE TABLE IF NOT EXISTS public.partners (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name TEXT NOT NULL,
    logo_url TEXT NOT NULL,
    active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Farmácias (Entidade Mestra)
CREATE TABLE IF NOT EXISTS public.pharmacies (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name TEXT NOT NULL,
    nif TEXT,
    address TEXT,
    phone TEXT,
    rating NUMERIC DEFAULT 5.0,
    delivery_fee NUMERIC DEFAULT 600,
    min_time TEXT DEFAULT '30-45 min',
    is_available BOOLEAN DEFAULT false,
    delivery_active BOOLEAN DEFAULT true,
    status TEXT DEFAULT 'PENDING',
    owner_email TEXT UNIQUE,
    commission_rate NUMERIC DEFAULT 10,
    receives_low_conf_rx BOOLEAN DEFAULT false,
    review_score NUMERIC DEFAULT 0,
    triage_count INTEGER DEFAULT 0,
    logo_url TEXT,
    description TEXT,
    opening_hours TEXT,
    payment_methods JSONB DEFAULT '[]',
    instagram TEXT,
    latitude NUMERIC,
    longitude NUMERIC,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Perfis de Usuário (Vinculados ao Auth)
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
    name TEXT,
    email TEXT,
    phone TEXT,
    address TEXT,
    role TEXT DEFAULT 'CUSTOMER', 
    pharmacy_id UUID REFERENCES public.pharmacies(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'ACTIVE',
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Catálogo Global (Mestre)
CREATE TABLE IF NOT EXISTS public.global_products (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    category TEXT,
    image TEXT DEFAULT 'https://cdn-icons-png.flaticon.com/512/883/883407.png',
    common BOOLEAN DEFAULT true,
    reference_price NUMERIC DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Produtos das Farmácias
CREATE TABLE IF NOT EXISTS public.products (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    price NUMERIC NOT NULL,
    stock INTEGER DEFAULT 0,
    pharmacy_id UUID REFERENCES public.pharmacies(id) ON DELETE CASCADE,
    image TEXT DEFAULT 'https://cdn-icons-png.flaticon.com/512/883/883407.png',
    requires_prescription BOOLEAN DEFAULT false,
    category TEXT DEFAULT 'GERAL',
    unit_type TEXT DEFAULT 'Unidade',
    global_product_id UUID REFERENCES public.global_products(id) ON DELETE SET NULL,
    is_promotion BOOLEAN DEFAULT false,
    discount_price NUMERIC,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Pedidos e Vendas (customer_id isola dados por utente)
CREATE TABLE IF NOT EXISTS public.orders (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    customer_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    customer_name TEXT,
    customer_phone TEXT,
    address TEXT,
    items JSONB, 
    total NUMERIC,
    status TEXT DEFAULT 'PENDENTE',
    type TEXT DEFAULT 'DELIVERY', 
    pharmacy_id UUID REFERENCES public.pharmacies(id),
    commission_amount NUMERIC DEFAULT 0,
    commission_status TEXT DEFAULT 'PENDING',
    commission_paid_amount NUMERIC DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Hardening financeiro idempotente (ambientes antigos podem nao ter colunas/consistencia)
ALTER TABLE public.orders
    ADD COLUMN IF NOT EXISTS commission_amount NUMERIC DEFAULT 0,
    ADD COLUMN IF NOT EXISTS commission_status TEXT DEFAULT 'PENDING',
    ADD COLUMN IF NOT EXISTS commission_paid_amount NUMERIC DEFAULT 0;

UPDATE public.orders
SET
    commission_amount = COALESCE(commission_amount, 0),
    commission_paid_amount = COALESCE(commission_paid_amount, 0),
    commission_status = CASE
        WHEN COALESCE(commission_paid_amount, 0) >= COALESCE(commission_amount, 0) AND COALESCE(commission_amount, 0) > 0 THEN 'PAID'
        WHEN COALESCE(commission_paid_amount, 0) > 0 THEN 'PARTIAL'
        ELSE 'PENDING'
    END
WHERE
    commission_amount IS NULL
    OR commission_paid_amount IS NULL
    OR commission_status IS NULL
    OR commission_status NOT IN ('PENDING', 'PARTIAL', 'PAID');

UPDATE public.orders
SET commission_amount = 0
WHERE commission_amount < 0;

UPDATE public.orders
SET commission_paid_amount = LEAST(
        GREATEST(COALESCE(commission_paid_amount, 0), 0),
        GREATEST(COALESCE(commission_amount, 0), 0)
    )
WHERE
    commission_paid_amount < 0
    OR commission_paid_amount > COALESCE(commission_amount, 0);

UPDATE public.orders
SET commission_status = CASE
        WHEN commission_paid_amount >= commission_amount AND commission_amount > 0 THEN 'PAID'
        WHEN commission_paid_amount > 0 THEN 'PARTIAL'
        ELSE 'PENDING'
    END
WHERE commission_status <> CASE
        WHEN commission_paid_amount >= commission_amount AND commission_amount > 0 THEN 'PAID'
        WHEN commission_paid_amount > 0 THEN 'PARTIAL'
        ELSE 'PENDING'
    END;

ALTER TABLE public.orders
    ALTER COLUMN commission_amount SET DEFAULT 0,
    ALTER COLUMN commission_status SET DEFAULT 'PENDING',
    ALTER COLUMN commission_paid_amount SET DEFAULT 0;

ALTER TABLE public.orders
    ALTER COLUMN commission_amount SET NOT NULL,
    ALTER COLUMN commission_status SET NOT NULL,
    ALTER COLUMN commission_paid_amount SET NOT NULL;

ALTER TABLE public.orders DROP CONSTRAINT IF EXISTS chk_orders_commission_status;
ALTER TABLE public.orders
    ADD CONSTRAINT chk_orders_commission_status
    CHECK (commission_status IN ('PENDING', 'PARTIAL', 'PAID'));

ALTER TABLE public.orders DROP CONSTRAINT IF EXISTS chk_orders_commission_amount_non_negative;
ALTER TABLE public.orders
    ADD CONSTRAINT chk_orders_commission_amount_non_negative
    CHECK (commission_amount >= 0);

ALTER TABLE public.orders DROP CONSTRAINT IF EXISTS chk_orders_commission_paid_bounds;
ALTER TABLE public.orders
    ADD CONSTRAINT chk_orders_commission_paid_bounds
    CHECK (commission_paid_amount >= 0 AND commission_paid_amount <= commission_amount);

CREATE INDEX IF NOT EXISTS idx_orders_customer ON public.orders(customer_id);

-- Avaliações
CREATE TABLE IF NOT EXISTS public.reviews (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    order_id UUID REFERENCES public.orders(id) ON DELETE CASCADE,
    pharmacy_id UUID REFERENCES public.pharmacies(id) ON DELETE CASCADE,
    customer_name TEXT,
    rating INTEGER CHECK (rating >= 1 AND rating <= 5),
    comment TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Receitas Médicas
CREATE TABLE IF NOT EXISTS public.prescriptions (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    customer_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
    image_url TEXT NOT NULL,
    image_hash TEXT, 
    notes TEXT,
    status TEXT DEFAULT 'ANALYZING',
    target_pharmacies JSONB DEFAULT '[]', 
    ai_metadata JSONB,
    triaged_at TIMESTAMPTZ,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Orçamentos de Receitas
CREATE TABLE IF NOT EXISTS public.prescription_quotes (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    prescription_id UUID REFERENCES public.prescriptions(id) ON DELETE CASCADE,
    pharmacy_id UUID REFERENCES public.pharmacies(id) ON DELETE CASCADE,
    pharmacy_name TEXT,
    items JSONB,
    total NUMERIC DEFAULT 0,
    delivery_fee NUMERIC DEFAULT 0,
    status TEXT DEFAULT 'RESPONDED',
    notes TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Suporte e Notificações
CREATE TABLE IF NOT EXISTS public.support_tickets (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
    user_name TEXT,
    user_email TEXT,
    subject TEXT,
    status TEXT DEFAULT 'OPEN',
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.support_messages (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    ticket_id UUID REFERENCES public.support_tickets(id) ON DELETE CASCADE,
    sender_id UUID,
    sender_name TEXT,
    sender_role TEXT,
    message TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.notifications (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
    title TEXT,
    message TEXT,
    type TEXT,
    is_read BOOLEAN DEFAULT false,
    link TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ========================================================================
-- FARMOBOT: ESTRUTURA ALINHADA AO PROJETO ATUAL
-- ========================================================================

-- Histórico utilizado diretamente pelo frontend atual (services/geminiService.ts)
CREATE TABLE IF NOT EXISTS public.bot_conversations (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
    role TEXT NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

ALTER TABLE public.bot_conversations
    ADD COLUMN IF NOT EXISTS user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
    ADD COLUMN IF NOT EXISTS role TEXT,
    ADD COLUMN IF NOT EXISTS content TEXT,
    ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ DEFAULT NOW();

UPDATE public.bot_conversations
SET role = COALESCE(role, 'model'),
    content = COALESCE(content, '')
WHERE role IS NULL OR content IS NULL;

ALTER TABLE public.bot_conversations
    ALTER COLUMN role SET NOT NULL,
    ALTER COLUMN content SET NOT NULL;

ALTER TABLE public.bot_conversations DROP CONSTRAINT IF EXISTS chk_bot_conversations_role;
ALTER TABLE public.bot_conversations
    ADD CONSTRAINT chk_bot_conversations_role
    CHECK (role IN ('user', 'model'));

DO $$ BEGIN
    CREATE TYPE public.conversation_status AS ENUM ('bot_active', 'escalated_pharmacy', 'escalated_admin', 'resolved');
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

DO $$ BEGIN
    CREATE TYPE public.bot_mode AS ENUM ('COMMERCIAL', 'EDUCATIONAL', 'SENSITIVE', 'NAVIGATION');
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

DO $$ BEGIN
    CREATE TYPE public.bot_risk_level AS ENUM ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL');
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

DO $$ BEGIN
    CREATE TYPE public.escalation_target AS ENUM ('BOT', 'PHARMACY', 'ADMIN');
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

DO $$ BEGIN
    CREATE TYPE public.actor_role AS ENUM ('USER', 'BOT', 'PHARMACY', 'ADMIN', 'SYSTEM');
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

CREATE TABLE IF NOT EXISTS public.conversations (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    pharmacy_id UUID REFERENCES public.pharmacies(id) ON DELETE SET NULL,
    status public.conversation_status NOT NULL DEFAULT 'bot_active',
    current_mode public.bot_mode NOT NULL DEFAULT 'NAVIGATION',
    risk_level public.bot_risk_level NOT NULL DEFAULT 'LOW',
    escalation_level SMALLINT NOT NULL DEFAULT 1 CHECK (escalation_level BETWEEN 1 AND 3),
    frustration_score INTEGER NOT NULL DEFAULT 0,
    unresolved_turns INTEGER NOT NULL DEFAULT 0,
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    resolved_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

ALTER TABLE public.conversations
    ADD COLUMN IF NOT EXISTS user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
    ADD COLUMN IF NOT EXISTS pharmacy_id UUID REFERENCES public.pharmacies(id) ON DELETE SET NULL,
    ADD COLUMN IF NOT EXISTS status public.conversation_status DEFAULT 'bot_active',
    ADD COLUMN IF NOT EXISTS current_mode public.bot_mode DEFAULT 'NAVIGATION',
    ADD COLUMN IF NOT EXISTS risk_level public.bot_risk_level DEFAULT 'LOW',
    ADD COLUMN IF NOT EXISTS escalation_level SMALLINT DEFAULT 1,
    ADD COLUMN IF NOT EXISTS frustration_score INTEGER DEFAULT 0,
    ADD COLUMN IF NOT EXISTS unresolved_turns INTEGER DEFAULT 0,
    ADD COLUMN IF NOT EXISTS last_message_at TIMESTAMPTZ DEFAULT NOW(),
    ADD COLUMN IF NOT EXISTS resolved_at TIMESTAMPTZ,
    ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT NOW();

ALTER TABLE public.conversations
    DROP COLUMN IF EXISTS last_escalation_reason,
    DROP COLUMN IF EXISTS clinical_flags,
    DROP COLUMN IF EXISTS behavior_flags,
    DROP COLUMN IF EXISTS complexity_flags,
    DROP COLUMN IF EXISTS compliance_notice_sent,
    DROP COLUMN IF EXISTS context_snapshot;

UPDATE public.conversations
SET
    status = COALESCE(status, 'bot_active'),
    current_mode = COALESCE(current_mode, 'NAVIGATION'),
    risk_level = COALESCE(risk_level, 'LOW'),
    escalation_level = COALESCE(escalation_level, 1),
    frustration_score = COALESCE(frustration_score, 0),
    unresolved_turns = COALESCE(unresolved_turns, 0),
    last_message_at = COALESCE(last_message_at, NOW()),
    updated_at = COALESCE(updated_at, NOW())
WHERE
    status IS NULL
    OR current_mode IS NULL
    OR risk_level IS NULL
    OR escalation_level IS NULL
    OR frustration_score IS NULL
    OR unresolved_turns IS NULL
    OR last_message_at IS NULL
    OR updated_at IS NULL;

ALTER TABLE public.conversations
    ALTER COLUMN user_id SET NOT NULL,
    ALTER COLUMN status SET NOT NULL,
    ALTER COLUMN current_mode SET NOT NULL,
    ALTER COLUMN risk_level SET NOT NULL,
    ALTER COLUMN escalation_level SET NOT NULL,
    ALTER COLUMN frustration_score SET NOT NULL,
    ALTER COLUMN unresolved_turns SET NOT NULL,
    ALTER COLUMN last_message_at SET NOT NULL,
    ALTER COLUMN updated_at SET NOT NULL;

ALTER TABLE public.conversations DROP CONSTRAINT IF EXISTS chk_conversations_escalation_level;
ALTER TABLE public.conversations
    ADD CONSTRAINT chk_conversations_escalation_level
    CHECK (escalation_level BETWEEN 1 AND 3);

ALTER TABLE public.conversations DROP CONSTRAINT IF EXISTS chk_conversations_score_non_negative;
ALTER TABLE public.conversations
    ADD CONSTRAINT chk_conversations_score_non_negative
    CHECK (frustration_score >= 0 AND unresolved_turns >= 0);

CREATE TABLE IF NOT EXISTS public.conversation_messages (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    conversation_id UUID NOT NULL REFERENCES public.conversations(id) ON DELETE CASCADE,
    user_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    role public.actor_role NOT NULL,
    content TEXT NOT NULL,
    mode public.bot_mode NOT NULL DEFAULT 'NAVIGATION',
    risk_level public.bot_risk_level NOT NULL DEFAULT 'LOW',
    trigger_flags JSONB NOT NULL DEFAULT '[]',
    action_events JSONB NOT NULL DEFAULT '[]',
    model_name TEXT,
    latency_ms INTEGER,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

ALTER TABLE public.conversation_messages
    ADD COLUMN IF NOT EXISTS mode public.bot_mode DEFAULT 'NAVIGATION',
    ADD COLUMN IF NOT EXISTS risk_level public.bot_risk_level DEFAULT 'LOW',
    ADD COLUMN IF NOT EXISTS trigger_flags JSONB DEFAULT '[]',
    ADD COLUMN IF NOT EXISTS action_events JSONB DEFAULT '[]',
    ADD COLUMN IF NOT EXISTS model_name TEXT,
    ADD COLUMN IF NOT EXISTS latency_ms INTEGER;

ALTER TABLE public.conversation_messages
    DROP COLUMN IF EXISTS escalation_target,
    DROP COLUMN IF EXISTS escalation_reason,
    DROP COLUMN IF EXISTS safety_notice,
    DROP COLUMN IF EXISTS decision_trace;

UPDATE public.conversation_messages
SET
    mode = COALESCE(mode, 'NAVIGATION'),
    risk_level = COALESCE(risk_level, 'LOW'),
    trigger_flags = COALESCE(trigger_flags, '[]'::JSONB),
    action_events = COALESCE(action_events, '[]'::JSONB)
WHERE
    mode IS NULL
    OR risk_level IS NULL
    OR trigger_flags IS NULL
    OR action_events IS NULL;

ALTER TABLE public.conversation_messages
    ALTER COLUMN mode SET DEFAULT 'NAVIGATION',
    ALTER COLUMN risk_level SET DEFAULT 'LOW',
    ALTER COLUMN mode SET NOT NULL,
    ALTER COLUMN risk_level SET NOT NULL,
    ALTER COLUMN trigger_flags SET NOT NULL,
    ALTER COLUMN action_events SET NOT NULL;

ALTER TABLE public.conversation_messages DROP CONSTRAINT IF EXISTS chk_conversation_messages_latency_non_negative;
ALTER TABLE public.conversation_messages
    ADD CONSTRAINT chk_conversation_messages_latency_non_negative
    CHECK (latency_ms IS NULL OR latency_ms >= 0);

ALTER TABLE public.conversation_messages DROP CONSTRAINT IF EXISTS chk_conversation_messages_trigger_flags_array;
ALTER TABLE public.conversation_messages
    ADD CONSTRAINT chk_conversation_messages_trigger_flags_array
    CHECK (jsonb_typeof(trigger_flags) = 'array');

ALTER TABLE public.conversation_messages DROP CONSTRAINT IF EXISTS chk_conversation_messages_action_events_array;
ALTER TABLE public.conversation_messages
    ADD CONSTRAINT chk_conversation_messages_action_events_array
    CHECK (jsonb_typeof(action_events) = 'array');

CREATE TABLE IF NOT EXISTS public.conversation_escalations (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    conversation_id UUID NOT NULL REFERENCES public.conversations(id) ON DELETE CASCADE,
    from_level SMALLINT NOT NULL CHECK (from_level BETWEEN 1 AND 3),
    to_level SMALLINT NOT NULL CHECK (to_level BETWEEN 1 AND 3),
    target public.escalation_target NOT NULL,
    reason_code TEXT NOT NULL,
    reason_text TEXT NOT NULL,
    risk_level public.bot_risk_level NOT NULL,
    trigger_snapshot JSONB NOT NULL DEFAULT '{}',
    status TEXT NOT NULL DEFAULT 'OPEN' CHECK (status IN ('OPEN', 'ACK', 'IN_PROGRESS', 'RESOLVED', 'EXPIRED', 'CANCELLED')),
    assigned_to UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    sla_due_at TIMESTAMPTZ,
    acknowledged_at TIMESTAMPTZ,
    resolved_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

ALTER TABLE public.conversation_escalations
    ADD COLUMN IF NOT EXISTS reason_code TEXT,
    ADD COLUMN IF NOT EXISTS reason_text TEXT;

ALTER TABLE public.conversation_escalations
    DROP COLUMN IF EXISTS message_id,
    DROP COLUMN IF EXISTS reason_type,
    DROP COLUMN IF EXISTS escalation_reason,
    DROP COLUMN IF EXISTS assigned_pharmacy_id,
    DROP COLUMN IF EXISTS resolution_note,
    DROP COLUMN IF EXISTS updated_at;

UPDATE public.conversation_escalations
SET
    reason_code = COALESCE(reason_code, 'UNSPECIFIED'),
    reason_text = COALESCE(reason_text, 'Escalonamento operacional')
WHERE reason_code IS NULL OR reason_text IS NULL;

ALTER TABLE public.conversation_escalations
    ALTER COLUMN reason_code SET NOT NULL,
    ALTER COLUMN reason_text SET NOT NULL;

ALTER TABLE public.conversation_escalations DROP CONSTRAINT IF EXISTS chk_conversation_escalation_levels;
ALTER TABLE public.conversation_escalations
    ADD CONSTRAINT chk_conversation_escalation_levels
    CHECK (to_level >= from_level AND from_level BETWEEN 1 AND 3 AND to_level BETWEEN 1 AND 3);

-- Limpeza de estruturas não usadas no projeto atual.
DROP TABLE IF EXISTS public.conversation_action_events CASCADE;
DROP TABLE IF EXISTS public.farmobot_trigger_catalog CASCADE;

DROP TRIGGER IF EXISTS tr_conversation_state_transition ON public.conversations;
DROP TRIGGER IF EXISTS tr_sync_conversation_from_message ON public.conversation_messages;

DO $$
DECLARE
    fn RECORD;
BEGIN
    FOR fn IN
        SELECT
            p.proname,
            pg_get_function_identity_arguments(p.oid) AS args
        FROM pg_proc p
        JOIN pg_namespace n ON n.oid = p.pronamespace
        WHERE n.nspname = 'public'
          AND p.proname IN (
              'is_valid_conversation_transition',
              'enforce_conversation_state_transition',
              'sync_conversation_from_message',
              'enqueue_farmobot_event'
          )
    LOOP
        EXECUTE format('DROP FUNCTION IF EXISTS public.%I(%s);', fn.proname, fn.args);
    END LOOP;
END $$;

DROP TYPE IF EXISTS public.app_event_status;
DROP TYPE IF EXISTS public.app_event_name;
DROP TYPE IF EXISTS public.escalation_reason_type;

-- ============================================================================
-- NOVO v1.6: TABELAS PARA GERENCIAMENTO DE CONTEÚDO DO ADMIN
-- ============================================================================

-- Banners Editáveis (Carrossel da página inicial)
CREATE TABLE IF NOT EXISTS public.admin_banners (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    title TEXT NOT NULL,
    subtitle TEXT,
    image_url TEXT,
    button_text TEXT DEFAULT 'Ver Mais',
    button_action TEXT DEFAULT 'pharmacies-list', -- Página para onde leva o clique
    "order" INTEGER DEFAULT 1,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Perguntas Frequentes (FAQ) Editável
CREATE TABLE IF NOT EXISTS public.admin_faq (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    question TEXT NOT NULL,
    answer TEXT NOT NULL,
    "order" INTEGER DEFAULT 1,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Sobre Nós (About) - Informações da Empresa
CREATE TABLE IF NOT EXISTS public.admin_about (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    section_type TEXT NOT NULL, -- 'mission', 'innovation', 'value'
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    icon_emoji TEXT, -- Para valores: ✓, 🛡️, ❤️, 🌍
    "order" INTEGER DEFAULT 1,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Configurações do Sistema (Taxa comissão, Whatsapp, Email, etc)
CREATE TABLE IF NOT EXISTS public.system_config (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    config_key TEXT UNIQUE NOT NULL, -- Ex: 'commission_rate', 'min_order_value', 'support_whatsapp'
    config_value TEXT,
    config_type TEXT DEFAULT 'text', -- 'text', 'number', 'boolean', 'json'
    description TEXT,
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Auditoria financeira (livro-razão de comissões)
CREATE TABLE IF NOT EXISTS public.financial_ledger (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    order_id UUID REFERENCES public.orders(id) ON DELETE SET NULL,
    pharmacy_id UUID REFERENCES public.pharmacies(id) ON DELETE SET NULL,
    period_key TEXT,
    cycle TEXT DEFAULT 'MONTHLY',
    operation_type TEXT DEFAULT 'SETTLEMENT', -- SETTLEMENT | RESET
    note TEXT,
    applied_amount NUMERIC DEFAULT 0,
    before_paid_amount NUMERIC DEFAULT 0,
    after_paid_amount NUMERIC DEFAULT 0,
    before_status TEXT,
    after_status TEXT,
    created_by UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================================================
-- 3. SEGURANÇA AVANÇADA (ROW LEVEL SECURITY - RLS)
-- ============================================================================

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.pharmacies ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.prescriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.prescription_quotes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.support_tickets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.support_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admin_banners ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admin_faq ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admin_about ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.system_config ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.financial_ledger ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bot_conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.conversation_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.conversation_escalations ENABLE ROW LEVEL SECURITY;

CREATE OR REPLACE FUNCTION is_admin() RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'ADMIN');
END; $$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION is_pharmacy_owner(p_id UUID) RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND pharmacy_id = p_id);
END; $$ LANGUAGE plpgsql SECURITY DEFINER;

-- POLÍTICAS PROFILES
DROP POLICY IF EXISTS "Profiles Access" ON public.profiles;
CREATE POLICY "Profiles Access" ON public.profiles FOR ALL USING (auth.uid() = id OR is_admin());
DROP POLICY IF EXISTS "Public Profile Insert" ON public.profiles;
CREATE POLICY "Public Profile Insert" ON public.profiles FOR INSERT WITH CHECK (true);

-- POLÍTICAS PHARMACIES
DROP POLICY IF EXISTS "Pharmacy View" ON public.pharmacies;
CREATE POLICY "Pharmacy View" ON public.pharmacies FOR SELECT USING (status = 'APPROVED' OR is_pharmacy_owner(id) OR is_admin());
DROP POLICY IF EXISTS "Pharmacy Owner Manage" ON public.pharmacies;
CREATE POLICY "Pharmacy Owner Manage" ON public.pharmacies FOR UPDATE USING (is_pharmacy_owner(id) OR is_admin());

-- POLÍTICAS PRODUCTS
DROP POLICY IF EXISTS "Product View" ON public.products;
CREATE POLICY "Product View" ON public.products FOR SELECT USING (true);
DROP POLICY IF EXISTS "Product Manage" ON public.products;
CREATE POLICY "Product Manage" ON public.products FOR ALL USING (is_pharmacy_owner(pharmacy_id) OR is_admin());

-- POLÍTICAS ORDERS
DROP POLICY IF EXISTS "Order Select" ON public.orders;
CREATE POLICY "Order Select" ON public.orders
FOR SELECT
USING (
    is_admin()
    OR is_pharmacy_owner(pharmacy_id)
    OR customer_id = auth.uid()
);
DROP POLICY IF EXISTS "Order Insert" ON public.orders;
CREATE POLICY "Order Insert" ON public.orders
FOR INSERT
WITH CHECK (
    is_admin()
    OR customer_id = auth.uid()
);
DROP POLICY IF EXISTS "Order Update" ON public.orders;
CREATE POLICY "Order Update" ON public.orders
FOR UPDATE
USING (is_pharmacy_owner(pharmacy_id) OR is_admin())
WITH CHECK (is_pharmacy_owner(pharmacy_id) OR is_admin());

-- POLÍTICAS PRESCRIPTIONS
DROP POLICY IF EXISTS "RX Access" ON public.prescriptions;
CREATE POLICY "RX Access" ON public.prescriptions FOR ALL USING (customer_id = auth.uid() OR is_admin());
DROP POLICY IF EXISTS "RX Pharmacy View" ON public.prescriptions;
CREATE POLICY "RX Pharmacy View" ON public.prescriptions FOR SELECT USING (
    (target_pharmacies::jsonb ? (SELECT pharmacy_id::text FROM public.profiles WHERE id = auth.uid())) OR
    status IN ('UNDER_REVIEW', 'WAITING_FOR_QUOTES')
);

-- POLÍTICAS SUPPORT_TICKETS
DROP POLICY IF EXISTS "Support Tickets Select" ON public.support_tickets;
CREATE POLICY "Support Tickets Select" ON public.support_tickets
FOR SELECT
USING (
    user_id = auth.uid()
    OR is_admin()
);
DROP POLICY IF EXISTS "Support Tickets Insert" ON public.support_tickets;
CREATE POLICY "Support Tickets Insert" ON public.support_tickets
FOR INSERT
WITH CHECK (
    user_id = auth.uid()
    OR is_admin()
);
DROP POLICY IF EXISTS "Support Tickets Update" ON public.support_tickets;
CREATE POLICY "Support Tickets Update" ON public.support_tickets
FOR UPDATE
USING (is_admin())
WITH CHECK (is_admin());

-- POLÍTICAS SUPPORT_MESSAGES
DROP POLICY IF EXISTS "Support Messages Select" ON public.support_messages;
CREATE POLICY "Support Messages Select" ON public.support_messages
FOR SELECT
USING (
    is_admin()
    OR EXISTS (
        SELECT 1
        FROM public.support_tickets t
        WHERE t.id = ticket_id
          AND t.user_id = auth.uid()
    )
);
DROP POLICY IF EXISTS "Support Messages Insert" ON public.support_messages;
CREATE POLICY "Support Messages Insert" ON public.support_messages
FOR INSERT
WITH CHECK (
    is_admin()
    OR (
        sender_id = auth.uid()
        AND EXISTS (
            SELECT 1
            FROM public.support_tickets t
            WHERE t.id = ticket_id
              AND t.user_id = auth.uid()
        )
    )
);

-- POLÍTICAS ADMIN_BANNERS (Todos podem ver, só admin pode editar)
DROP POLICY IF EXISTS "Banners Public View" ON public.admin_banners;
CREATE POLICY "Banners Public View" ON public.admin_banners FOR SELECT USING (true);
DROP POLICY IF EXISTS "Banners Admin Edit" ON public.admin_banners;
CREATE POLICY "Banners Admin Edit" ON public.admin_banners FOR ALL USING (is_admin());

-- POLÍTICAS ADMIN_FAQ (Todos podem ver, só admin pode editar)
DROP POLICY IF EXISTS "FAQ Public View" ON public.admin_faq;
CREATE POLICY "FAQ Public View" ON public.admin_faq FOR SELECT USING (true);
DROP POLICY IF EXISTS "FAQ Admin Edit" ON public.admin_faq;
CREATE POLICY "FAQ Admin Edit" ON public.admin_faq FOR ALL USING (is_admin());

-- POLÍTICAS ADMIN_ABOUT (Todos podem ver, só admin pode editar)
DROP POLICY IF EXISTS "About Public View" ON public.admin_about;
CREATE POLICY "About Public View" ON public.admin_about FOR SELECT USING (true);
DROP POLICY IF EXISTS "About Admin Edit" ON public.admin_about;
CREATE POLICY "About Admin Edit" ON public.admin_about FOR ALL USING (is_admin());

-- POLÍTICAS SYSTEM_CONFIG (Todos podem ler configs públicas, só admin pode editar)
DROP POLICY IF EXISTS "Config Public View" ON public.system_config;
CREATE POLICY "Config Public View" ON public.system_config FOR SELECT USING (true);
DROP POLICY IF EXISTS "Config Admin Edit" ON public.system_config;
CREATE POLICY "Config Admin Edit" ON public.system_config FOR ALL USING (is_admin());

-- POLÍTICAS FINANCIAL_LEDGER (somente admin)
DROP POLICY IF EXISTS "Ledger Admin View" ON public.financial_ledger;
CREATE POLICY "Ledger Admin View" ON public.financial_ledger FOR SELECT USING (is_admin());
DROP POLICY IF EXISTS "Ledger Admin Insert" ON public.financial_ledger;
CREATE POLICY "Ledger Admin Insert" ON public.financial_ledger FOR INSERT WITH CHECK (is_admin());

-- POLÍTICAS FARMOBOT (histórico legado + conversas estruturadas)
DROP POLICY IF EXISTS "Bot Conversations Select" ON public.bot_conversations;
CREATE POLICY "Bot Conversations Select" ON public.bot_conversations
FOR SELECT
USING (
    user_id = auth.uid()
    OR is_admin()
);

DROP POLICY IF EXISTS "Bot Conversations Insert" ON public.bot_conversations;
CREATE POLICY "Bot Conversations Insert" ON public.bot_conversations
FOR INSERT
WITH CHECK (
    (user_id = auth.uid() AND role IN ('user', 'model'))
    OR is_admin()
);

DROP POLICY IF EXISTS "Bot Conversations Delete" ON public.bot_conversations;
CREATE POLICY "Bot Conversations Delete" ON public.bot_conversations
FOR DELETE
USING (
    user_id = auth.uid()
    OR is_admin()
);

DROP POLICY IF EXISTS "Conversations Select" ON public.conversations;
CREATE POLICY "Conversations Select" ON public.conversations
FOR SELECT
USING (
    user_id = auth.uid()
    OR is_admin()
    OR (pharmacy_id IS NOT NULL AND is_pharmacy_owner(pharmacy_id))
);

DROP POLICY IF EXISTS "Conversations Insert" ON public.conversations;
CREATE POLICY "Conversations Insert" ON public.conversations
FOR INSERT
WITH CHECK (
    user_id = auth.uid()
    OR is_admin()
);

DROP POLICY IF EXISTS "Conversations Update" ON public.conversations;
CREATE POLICY "Conversations Update" ON public.conversations
FOR UPDATE
USING (
    user_id = auth.uid()
    OR is_admin()
    OR (pharmacy_id IS NOT NULL AND is_pharmacy_owner(pharmacy_id))
)
WITH CHECK (
    user_id = auth.uid()
    OR is_admin()
    OR (pharmacy_id IS NOT NULL AND is_pharmacy_owner(pharmacy_id))
);

DROP POLICY IF EXISTS "Conversation Messages Select" ON public.conversation_messages;
CREATE POLICY "Conversation Messages Select" ON public.conversation_messages
FOR SELECT
USING (
    EXISTS (
        SELECT 1
        FROM public.conversations c
        WHERE c.id = conversation_id
          AND (
              c.user_id = auth.uid()
              OR is_admin()
              OR (c.pharmacy_id IS NOT NULL AND is_pharmacy_owner(c.pharmacy_id))
          )
    )
);

DROP POLICY IF EXISTS "Conversation Messages Insert" ON public.conversation_messages;
DROP POLICY IF EXISTS "Conversation Messages Insert User" ON public.conversation_messages;
CREATE POLICY "Conversation Messages Insert User" ON public.conversation_messages
FOR INSERT
WITH CHECK (
    role = 'USER'
    AND user_id = auth.uid()
    AND EXISTS (
        SELECT 1
        FROM public.conversations c
        WHERE c.id = conversation_id
          AND c.user_id = auth.uid()
    )
);

DROP POLICY IF EXISTS "Conversation Messages Insert Pharmacy" ON public.conversation_messages;
CREATE POLICY "Conversation Messages Insert Pharmacy" ON public.conversation_messages
FOR INSERT
WITH CHECK (
    role = 'PHARMACY'
    AND user_id = auth.uid()
    AND EXISTS (
        SELECT 1
        FROM public.conversations c
        WHERE c.id = conversation_id
          AND c.pharmacy_id IS NOT NULL
          AND is_pharmacy_owner(c.pharmacy_id)
    )
);

DROP POLICY IF EXISTS "Conversation Messages Insert Admin" ON public.conversation_messages;
CREATE POLICY "Conversation Messages Insert Admin" ON public.conversation_messages
FOR INSERT
WITH CHECK (is_admin());

DROP POLICY IF EXISTS "Conversation Escalations Select" ON public.conversation_escalations;
CREATE POLICY "Conversation Escalations Select" ON public.conversation_escalations
FOR SELECT
USING (
    is_admin()
    OR EXISTS (
        SELECT 1
        FROM public.conversations c
        WHERE c.id = conversation_id
          AND c.user_id = auth.uid()
    )
    OR EXISTS (
        SELECT 1
        FROM public.conversations c
        WHERE c.id = conversation_id
          AND c.pharmacy_id IS NOT NULL
          AND is_pharmacy_owner(c.pharmacy_id)
    )
);

DROP POLICY IF EXISTS "Conversation Escalations Insert" ON public.conversation_escalations;
CREATE POLICY "Conversation Escalations Insert" ON public.conversation_escalations
FOR INSERT
WITH CHECK (is_admin());

DROP POLICY IF EXISTS "Conversation Escalations Update" ON public.conversation_escalations;
CREATE POLICY "Conversation Escalations Update" ON public.conversation_escalations
FOR UPDATE
USING (
    is_admin()
    OR (
        status IN ('OPEN', 'ACK', 'IN_PROGRESS')
        AND EXISTS (
            SELECT 1
            FROM public.conversations c
            WHERE c.id = conversation_id
              AND c.pharmacy_id IS NOT NULL
              AND is_pharmacy_owner(c.pharmacy_id)
        )
    )
)
WITH CHECK (
    is_admin()
    OR (
        status IN ('ACK', 'IN_PROGRESS', 'RESOLVED')
        AND EXISTS (
            SELECT 1
            FROM public.conversations c
            WHERE c.id = conversation_id
              AND c.pharmacy_id IS NOT NULL
              AND is_pharmacy_owner(c.pharmacy_id)
        )
    )
);

-- ============================================================================
-- 4. AUTOMAÇÃO DE STOCK (FIXED: SUPORTE A ITENS MANUAIS)
-- ============================================================================

CREATE OR REPLACE FUNCTION process_stock_decrement()
RETURNS TRIGGER AS $$
DECLARE
    item JSONB;
    item_id_text TEXT;
    qty INTEGER;
BEGIN
    IF NEW.items IS NOT NULL THEN
        FOR item IN SELECT * FROM jsonb_array_elements(NEW.items)
        LOOP
            item_id_text := item->>'id';
            qty := (item->>'quantity')::INTEGER;

            -- CORREÇÃO CRÍTICA: Só tenta atualizar o stock se o ID for um UUID válido.
            -- Itens manuais (ex: 'rx-...') são ignorados no stock mas mantidos na venda.
            IF item_id_text ~ '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$' THEN
                UPDATE public.products
                SET stock = stock - qty
                WHERE id = item_id_text::UUID;
            END IF;
        END LOOP;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS tr_decrement_stock ON public.orders;
CREATE TRIGGER tr_decrement_stock AFTER INSERT ON public.orders FOR EACH ROW EXECUTE FUNCTION process_stock_decrement();

CREATE OR REPLACE FUNCTION protect_commission_status_update()
RETURNS TRIGGER AS $$
BEGIN
    IF (
        NEW.commission_status IS DISTINCT FROM OLD.commission_status
        OR COALESCE(NEW.commission_paid_amount, 0) IS DISTINCT FROM COALESCE(OLD.commission_paid_amount, 0)
        OR COALESCE(NEW.commission_amount, 0) IS DISTINCT FROM COALESCE(OLD.commission_amount, 0)
    ) AND NOT is_admin() THEN
        RAISE EXCEPTION 'Somente admin pode alterar campos financeiros de comissao.';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS tr_protect_commission_status ON public.orders;
CREATE TRIGGER tr_protect_commission_status
BEFORE UPDATE ON public.orders
FOR EACH ROW EXECUTE FUNCTION protect_commission_status_update();

CREATE OR REPLACE FUNCTION public.get_period_range(period_key TEXT, cycle TEXT)
RETURNS TABLE(start_iso TIMESTAMPTZ, end_iso TIMESTAMPTZ) AS $$
DECLARE
    month_num INTEGER;
    year_num INTEGER;
    week_num INTEGER;
    jan4 DATE;
    week1_monday DATE;
BEGIN
    IF cycle = 'MONTHLY' THEN
        month_num := split_part(period_key, '/', 1)::INTEGER;
        year_num := split_part(period_key, '/', 2)::INTEGER;

        IF month_num < 1 OR month_num > 12 OR year_num < 2000 THEN
            RAISE EXCEPTION 'Periodo mensal invalido: %', period_key;
        END IF;

        start_iso := make_timestamptz(year_num, month_num, 1, 0, 0, 0, 'UTC');
        end_iso := (start_iso + INTERVAL '1 month');
        RETURN NEXT;
        RETURN;
    END IF;

    year_num := split_part(period_key, '-W', 1)::INTEGER;
    week_num := split_part(period_key, '-W', 2)::INTEGER;

    IF week_num < 1 OR week_num > 53 OR year_num < 2000 THEN
        RAISE EXCEPTION 'Periodo semanal invalido: %', period_key;
    END IF;

    jan4 := make_date(year_num, 1, 4);
    week1_monday := jan4 - ((extract(isodow from jan4)::INTEGER) - 1);
    start_iso := (week1_monday + ((week_num - 1) * 7))::TIMESTAMPTZ;
    end_iso := start_iso + INTERVAL '7 day';
    RETURN NEXT;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.normalize_order_status(p_status TEXT)
RETURNS TEXT AS $$
    SELECT upper(
        translate(
            COALESCE(p_status, ''),
            U&'\00C1\00C0\00C2\00C3\00C4\00C9\00C8\00CA\00CB\00CD\00CC\00CE\00CF\00D3\00D2\00D4\00D5\00D6\00DA\00D9\00DB\00DC\00C7\00E1\00E0\00E2\00E3\00E4\00E9\00E8\00EA\00EB\00ED\00EC\00EE\00EF\00F3\00F2\00F4\00F5\00F6\00FA\00F9\00FB\00FC\00E7',
            'AAAAAEEEEIIIIOOOOOUUUUCaaaaaeeeeiiiiooooouuuuc'
        )
    );
$$ LANGUAGE sql IMMUTABLE;

CREATE OR REPLACE FUNCTION public.is_order_completed(p_status TEXT)
RETURNS BOOLEAN AS $$
    SELECT public.normalize_order_status(p_status) IN ('CONCLUIDO', 'COMPLETED');
$$ LANGUAGE sql IMMUTABLE;

CREATE OR REPLACE FUNCTION public.apply_commission_payment_by_period_admin(
    p_pharmacy_id UUID,
    p_period_key TEXT,
    p_cycle TEXT DEFAULT 'MONTHLY',
    p_payment_amount NUMERIC DEFAULT NULL,
    p_note TEXT DEFAULT NULL
)
RETURNS TABLE(updated_count INTEGER, applied_amount NUMERIC, remaining_amount NUMERIC) AS $$
DECLARE
    v_start TIMESTAMPTZ;
    v_end TIMESTAMPTZ;
    v_remaining NUMERIC;
    v_updated INTEGER := 0;
    v_applied NUMERIC := 0;
    rec RECORD;
    v_commission NUMERIC;
    v_paid NUMERIC;
    v_outstanding NUMERIC;
    v_apply NUMERIC;
    v_next_paid NUMERIC;
    v_next_status TEXT;
BEGIN
    IF NOT is_admin() THEN
        RAISE EXCEPTION 'Somente admin pode liquidar comissao.';
    END IF;

    p_cycle := upper(COALESCE(p_cycle, 'MONTHLY'));
    IF p_cycle NOT IN ('MONTHLY', 'WEEKLY') THEN
        RAISE EXCEPTION 'Ciclo invalido: %', p_cycle;
    END IF;

    IF p_payment_amount IS NOT NULL AND p_payment_amount < 0 THEN
        RAISE EXCEPTION 'Valor de pagamento invalido: %', p_payment_amount;
    END IF;

    SELECT start_iso, end_iso
    INTO v_start, v_end
    FROM public.get_period_range(p_period_key, p_cycle);

    v_remaining := COALESCE(NULLIF(p_payment_amount, 0), 1e18);

    FOR rec IN
        SELECT id, pharmacy_id, commission_amount, commission_status, commission_paid_amount, created_at, status
        FROM public.orders
        WHERE pharmacy_id = p_pharmacy_id
          AND created_at >= v_start
          AND created_at < v_end
          AND public.is_order_completed(status)
        ORDER BY created_at ASC
        FOR UPDATE SKIP LOCKED
    LOOP
        EXIT WHEN v_remaining <= 0;

        v_commission := COALESCE(rec.commission_amount, 0);
        v_paid := LEAST(
            v_commission,
            GREATEST(
                0,
                COALESCE(rec.commission_paid_amount, 0)
                + CASE WHEN rec.commission_status = 'PAID' AND COALESCE(rec.commission_paid_amount, 0) <= 0 THEN v_commission ELSE 0 END
            )
        );
        v_outstanding := GREATEST(0, v_commission - v_paid);
        IF v_outstanding <= 0 THEN
            CONTINUE;
        END IF;

        v_apply := LEAST(v_outstanding, v_remaining);
        v_next_paid := v_paid + v_apply;
        v_next_status := CASE WHEN v_next_paid >= v_commission THEN 'PAID' ELSE 'PARTIAL' END;

        UPDATE public.orders
        SET commission_paid_amount = v_next_paid,
            commission_status = v_next_status
        WHERE id = rec.id;

        INSERT INTO public.financial_ledger (
            order_id, pharmacy_id, period_key, cycle, operation_type, note,
            applied_amount, before_paid_amount, after_paid_amount,
            before_status, after_status, created_by
        ) VALUES (
            rec.id, rec.pharmacy_id, p_period_key, p_cycle, 'SETTLEMENT', p_note,
            v_apply, v_paid, v_next_paid,
            rec.commission_status, v_next_status, auth.uid()
        );

        v_updated := v_updated + 1;
        v_applied := v_applied + v_apply;
        v_remaining := v_remaining - v_apply;
    END LOOP;

    updated_count := v_updated;
    applied_amount := v_applied;
    remaining_amount := CASE WHEN p_payment_amount IS NULL OR p_payment_amount <= 0 THEN 0 ELSE GREATEST(0, v_remaining) END;
    RETURN NEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Ferramenta administrativa: reset controlado das dividas de comissao (opcional por farmácia).
CREATE OR REPLACE FUNCTION public.reset_commission_debt_admin(target_pharmacy_id UUID DEFAULT NULL)
RETURNS INTEGER AS $$
DECLARE
    affected_rows INTEGER := 0;
    rec RECORD;
BEGIN
    IF NOT is_admin() THEN
        RAISE EXCEPTION 'Somente admin pode executar reset de divida.';
    END IF;

    FOR rec IN
        SELECT id, pharmacy_id, commission_paid_amount, commission_status
        FROM public.orders
        WHERE (
            target_pharmacy_id IS NULL OR pharmacy_id = target_pharmacy_id
        )
        AND public.is_order_completed(status)
        FOR UPDATE SKIP LOCKED
    LOOP
        UPDATE public.orders
        SET commission_status = 'PENDING',
            commission_paid_amount = 0
        WHERE id = rec.id;

        INSERT INTO public.financial_ledger (
            order_id, pharmacy_id, period_key, cycle, operation_type, note,
            applied_amount, before_paid_amount, after_paid_amount,
            before_status, after_status, created_by
        ) VALUES (
            rec.id, rec.pharmacy_id, NULL, 'MONTHLY', 'RESET', 'Reset administrativo de dívida',
            0, COALESCE(rec.commission_paid_amount, 0), 0,
            rec.commission_status, 'PENDING', auth.uid()
        );

        affected_rows := affected_rows + 1;
    END LOOP;

    RETURN affected_rows;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- 5. GATILHOS DE NOTIFICAÇÃO (SISTEMA DE ALERTAS RESTAURADO)
-- ============================================================================

-- Notificar Cliente sobre Orçamento
CREATE OR REPLACE FUNCTION notify_customer_on_quote()
RETURNS trigger AS $$
BEGIN
    INSERT INTO notifications (user_id, title, message, type)
    SELECT customer_id, 'ORÇAMENTO RECEBIDO 💰', 'A ' || NEW.pharmacy_name || ' respondeu à tua receita. Toque para ver.', 'RX_RESPONSE'
    FROM prescriptions WHERE id = NEW.prescription_id;
    RETURN NEW;
END; $$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS tr_notify_quote ON prescription_quotes;
CREATE TRIGGER tr_notify_quote AFTER INSERT ON prescription_quotes FOR EACH ROW EXECUTE FUNCTION notify_customer_on_quote();

-- Notificar Farmácias sobre novas Receitas/Triagens
CREATE OR REPLACE FUNCTION notify_pharmacies_on_rx()
RETURNS trigger AS $$
DECLARE
    target_p_id TEXT;
    expert_user_id UUID;
    customer_name TEXT;
BEGIN
    SELECT name INTO customer_name FROM profiles WHERE id = NEW.customer_id;
    IF customer_name IS NULL THEN customer_name := 'UM UTENTE'; END IF;

    -- 1. Triagem (Letra Difícil)
    IF NEW.status = 'UNDER_REVIEW' THEN
        FOR expert_user_id IN (SELECT p.id FROM profiles p JOIN pharmacies ph ON p.pharmacy_id = ph.id WHERE ph.receives_low_conf_rx = true) LOOP
            INSERT INTO notifications (user_id, title, message, type)
            VALUES (expert_user_id, 'LETRA DIFÍCIL PARA ANALISAR', 'Uma receita de ' || customer_name || ' precisa da tua ajuda profissional.', 'RX_TRIAGE');
        END LOOP;

    -- 2. Cotação Direta
    ELSIF NEW.status = 'WAITING_FOR_QUOTES' THEN
        IF NEW.target_pharmacies IS NOT NULL AND jsonb_typeof(NEW.target_pharmacies) = 'array' THEN
            FOR target_p_id IN (SELECT jsonb_array_elements_text(NEW.target_pharmacies)) LOOP
                INSERT INTO notifications (user_id, title, message, type)
                SELECT id, 'PEDIDO DE ORÇAMENTO', 'Recebeste uma nova receita de ' || customer_name || ' para cotar.', 'RX_QUOTE'
                FROM profiles WHERE pharmacy_id = target_p_id::uuid;
            END LOOP;
        END IF;
    END IF;

    RETURN NEW;
END; $$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS tr_notify_rx ON prescriptions;
CREATE TRIGGER tr_notify_rx AFTER INSERT OR UPDATE OF status ON prescriptions FOR EACH ROW EXECUTE FUNCTION notify_pharmacies_on_rx();

-- 6. ÍNDICES DE PERFORMANCE
CREATE INDEX IF NOT EXISTS idx_products_name_trgm ON public.products USING gin (name gin_trgm_ops);
CREATE INDEX IF NOT EXISTS idx_orders_pharmacy ON public.orders(pharmacy_id);
CREATE INDEX IF NOT EXISTS idx_orders_commission_status_created_at ON public.orders(commission_status, created_at);
CREATE INDEX IF NOT EXISTS idx_orders_commission_paid_amount ON public.orders(commission_paid_amount);
CREATE INDEX IF NOT EXISTS idx_orders_completed_by_pharmacy_created
ON public.orders(pharmacy_id, created_at)
WHERE public.is_order_completed(status);
CREATE INDEX IF NOT EXISTS idx_orders_open_commission_by_pharmacy_created
ON public.orders(pharmacy_id, commission_status, created_at)
WHERE commission_status IN ('PENDING', 'PARTIAL');
CREATE INDEX IF NOT EXISTS idx_prescriptions_customer ON public.prescriptions(customer_id);
CREATE INDEX IF NOT EXISTS idx_admin_banners_order ON public.admin_banners("order");
CREATE INDEX IF NOT EXISTS idx_admin_faq_order ON public.admin_faq("order");
CREATE INDEX IF NOT EXISTS idx_system_config_key ON public.system_config(config_key);
CREATE INDEX IF NOT EXISTS idx_financial_ledger_order ON public.financial_ledger(order_id);
CREATE INDEX IF NOT EXISTS idx_financial_ledger_pharmacy_created ON public.financial_ledger(pharmacy_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_bot_conversations_user_created ON public.bot_conversations(user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_conversations_user_status_updated ON public.conversations(user_id, status, updated_at DESC);
CREATE INDEX IF NOT EXISTS idx_conversations_pharmacy_status_updated ON public.conversations(pharmacy_id, status, updated_at DESC);
CREATE INDEX IF NOT EXISTS idx_conversations_level_risk_updated ON public.conversations(escalation_level, risk_level, updated_at DESC);
CREATE INDEX IF NOT EXISTS idx_conversations_last_message ON public.conversations(last_message_at DESC);
CREATE INDEX IF NOT EXISTS idx_conversation_messages_conv_created ON public.conversation_messages(conversation_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_conversation_messages_mode_risk_created ON public.conversation_messages(mode, risk_level, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_conversation_messages_role_created ON public.conversation_messages(role, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_conversation_messages_trigger_flags ON public.conversation_messages USING gin (trigger_flags);
CREATE INDEX IF NOT EXISTS idx_conversation_messages_action_events ON public.conversation_messages USING gin (action_events);
CREATE INDEX IF NOT EXISTS idx_conversation_escalations_status_target_due ON public.conversation_escalations(status, target, sla_due_at);
CREATE INDEX IF NOT EXISTS idx_conversation_escalations_conv_created ON public.conversation_escalations(conversation_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_conversation_escalations_assigned_status_due ON public.conversation_escalations(assigned_to, status, sla_due_at);

-- ============================================================================
-- 7. DADOS INICIAIS PADRÃO (v1.6)
-- ============================================================================

-- Inserir dados iniciais de FAQ (se a tabela estiver vazia)
INSERT INTO public.admin_faq (question, answer, "order", is_active)
SELECT * FROM (VALUES
  ('Como compro na FarmoLink?', 'Podes pesquisar diretamente pelo nome do medicamento na tela inicial, ou tirar uma foto da tua receita médica. A IA analisará a receita e mostrará os medicamentos disponíveis nas farmácias mais próximas, com os respetivos preços.', 1, true),
  ('Faz entregas?', 'Sim! Algumas farmácias têm entrega própria e outras permitem apenas levantamento em loja. Quando fazes a compra, a plataforma já indica se a farmácia faz entrega ou levantamento.', 2, true),
  ('Precisa da receita física?', 'SIM. A entrega de medicamentos sujeitos a receita médica só será feita se entregares a receita original física ao estafeta. Isto é uma exigência legal em Angola e protege a tua saúde.', 3, true),
  ('Como pago?', 'Diretamente à farmácia ou ao estafeta no ato da entrega. Aceitamos pagamento via TPA (Multicaixa), MCX Express ou dinheiro.', 4, true),
  ('A IA pode errar a ler a receita?', 'Sim, a IA é apenas um assistente. O farmacêutico da farmácia fará sempre uma verificação manual da foto da receita antes de preparar a encomenda. A segurança é prioridade.', 5, true),
  ('Os preços são iguais à loja?', 'Sim. As farmácias parceiras comprometem-se a praticar os mesmos preços que cobram no balcão físico. Sem surpresas.', 6, true),
  ('Os meus dados estão seguros?', 'Sim. Todos os teus dados são criptografados e protegidos conforme a Lei de Proteção de Dados de Angola (APD). Usamos servidores seguros e não partilhamos informações pessoais com terceiros sem consentimento.', 7, true),
  ('Posso devolver um medicamento?', 'Medicamentos só podem ser devolvidos se chegarem danificados ou com defeito. Contacta-nos imediatamente se isto acontecer e solucionaremos o problema.', 8, true)
) t(question, answer, "order", is_active)
WHERE NOT EXISTS (SELECT 1 FROM public.admin_faq LIMIT 1);

-- Inserir dados iniciais de Sobre Nós
INSERT INTO public.admin_about (section_type, title, content, icon_emoji, "order", is_active)
SELECT * FROM (VALUES
  ('mission', 'Nossa Missão', 'Digitalizar o ecossistema farmacêutico angolano, proporcionando transparência de preços e conveniência para todos os utilizadores, de Luanda a Cabinda.', '🌍', 1, true),
  ('innovation', 'Inovação Local', 'Criado por angolanos para angolanos, entendemos os desafios logísticos e de literacia digital. Trabalhamos diretamente com farmacêuticos para oferecer soluções reais.', '⚡', 2, true),
  ('value', 'Transparência', 'Preços reais das farmácias em tempo real, sem surpresas.', '✓', 3, true),
  ('value', 'Segurança', 'Dados protegidos conforme a Lei de Proteção de Dados de Angola (APD).', '🛡️', 4, true),
  ('value', 'Ética', 'Sempre exigimos a receita original para entrega de medicamentos.', '❤️', 5, true),
  ('value', 'Acessibilidade', 'Feito para funcionar em qualquer telemóvel com dados móveis.', '🌍', 6, true)
) t(section_type, title, content, icon_emoji, "order", is_active)
WHERE NOT EXISTS (SELECT 1 FROM public.admin_about LIMIT 1);

-- Inserir dados iniciais de Configurações do Sistema
INSERT INTO public.system_config (config_key, config_value, config_type, description)
SELECT * FROM (VALUES
  ('commission_rate', '10', 'number', 'Taxa de comissão padrão (%)'),
  ('min_order_value', '2000', 'number', 'Valor mínimo de pedido (Kz)'),
  ('support_whatsapp', '244936793706', 'text', 'Número de WhatsApp do suporte'),
  ('support_email', 'ajuda@farmolink.ao', 'text', 'Email de suporte'),
  ('app_name', 'FarmoLink Angola', 'text', 'Nome da aplicação'),
  ('app_version', '1.5.0', 'text', 'Versão atual da aplicação'),
  ('legal_updated_at', '2026-02-12', 'text', 'Data da ultima atualizacao legal (YYYY-MM-DD)'),
  ('legal_privacy_policy', 'Politica de Privacidade FarmoLink: coletamos dados de cadastro, uso da plataforma, pedidos e informacoes relacionadas a receitas para executar o servico com seguranca. Dados de saude recebem controles reforcados de acesso e criptografia. Compartilhamos informacoes apenas com farmacias parceiras e fornecedores estritamente necessarios para processar pedidos, suporte e obrigacoes legais. O titular pode solicitar correcao e atualizacao de dados pelos canais oficiais. Nao vendemos dados pessoais. Retemos informacoes pelo periodo necessario para operacao, auditoria e cumprimento legal aplicavel. Ao continuar a usar a plataforma, o utilizador reconhece e aceita esta politica na versao vigente.', 'text', 'Conteudo da Politica de Privacidade'),
  ('legal_terms_of_use', 'Termos de Uso FarmoLink: a plataforma intermedeia pedidos entre utentes e farmacias parceiras e nao substitui consulta medica. Medicamentos sujeitos a receita exigem validacao profissional e cumprimento das regras legais aplicaveis. O utilizador deve fornecer dados verdadeiros, manter credenciais seguras e usar a plataforma de forma licita. E proibido tentar adquirir medicamentos controlados sem receita valida, praticar fraude ou uso abusivo do sistema. Preco, disponibilidade, entrega e dispensacao sao definidos pela farmacia parceira, com possibilidade de recusas por motivos tecnicos, regulatorios ou de stock. A FarmoLink pode suspender contas em caso de violacao destes termos.', 'text', 'Conteudo dos Termos de Uso'),
  ('financial_settlement_cycle', 'MONTHLY', 'text', 'Periodicidade de liquidacao financeira (MONTHLY|WEEKLY)')
) t(config_key, config_value, config_type, description)
ON CONFLICT (config_key) DO NOTHING;

-- Atualizacao de contato WhatsApp (garante numero mais recente em bases existentes).
UPDATE public.system_config
SET config_value = '244936793706',
    updated_at = NOW()
WHERE config_key = 'support_whatsapp';

-- Garantia legal: se a base ja existir com placeholders/vazios, preencher com texto adequado.
UPDATE public.system_config
SET config_value = 'Politica de Privacidade FarmoLink: coletamos dados de cadastro, uso da plataforma, pedidos e informacoes relacionadas a receitas para executar o servico com seguranca. Dados de saude recebem controles reforcados de acesso e criptografia. Compartilhamos informacoes apenas com farmacias parceiras e fornecedores estritamente necessarios para processar pedidos, suporte e obrigacoes legais. O titular pode solicitar correcao e atualizacao de dados pelos canais oficiais. Nao vendemos dados pessoais. Retemos informacoes pelo periodo necessario para operacao, auditoria e cumprimento legal aplicavel. Ao continuar a usar a plataforma, o utilizador reconhece e aceita esta politica na versao vigente.',
    updated_at = NOW()
WHERE config_key = 'legal_privacy_policy'
  AND (
    config_value IS NULL
    OR btrim(config_value) = ''
    OR config_value ILIKE 'Texto padrao%'
  );

UPDATE public.system_config
SET config_value = 'Termos de Uso FarmoLink: a plataforma intermedeia pedidos entre utentes e farmacias parceiras e nao substitui consulta medica. Medicamentos sujeitos a receita exigem validacao profissional e cumprimento das regras legais aplicaveis. O utilizador deve fornecer dados verdadeiros, manter credenciais seguras e usar a plataforma de forma licita. E proibido tentar adquirir medicamentos controlados sem receita valida, praticar fraude ou uso abusivo do sistema. Preco, disponibilidade, entrega e dispensacao sao definidos pela farmacia parceira, com possibilidade de recusas por motivos tecnicos, regulatorios ou de stock. A FarmoLink pode suspender contas em caso de violacao destes termos.',
    updated_at = NOW()
WHERE config_key = 'legal_terms_of_use'
  AND (
    config_value IS NULL
    OR btrim(config_value) = ''
    OR config_value ILIKE 'Texto padrao%'
  );

-- Inserir dados iniciais de Banners (exemplo)
INSERT INTO public.admin_banners (title, subtitle, button_text, "order", is_active)
SELECT * FROM (VALUES
  ('Medicamentos em Promoção', 'Descontos especiais esta semana até 50%', 'Ver Ofertas', 1, true),
  ('Novos Parceiros Disponíveis', 'Farmácias de qualidade perto de ti', 'Explorar', 2, true)
) t(title, subtitle, button_text, "order", is_active)
WHERE NOT EXISTS (SELECT 1 FROM public.admin_banners LIMIT 1);

NOTIFY pgrst, 'reload schema';

-- ============================================================================
-- SUMÁRIO DE MUDANÇAS v1.6
-- ============================================================================
-- ✨ NOVAS TABELAS:
--    1. admin_banners - Carrossel de banners da página inicial (título, subtítulo, imagem, botão)
--    2. admin_faq - Perguntas Frequentes geridas pelo admin
--    3. admin_about - Informações sobre a empresa (missão, inovação, valores)
--    4. system_config - Configurações globais do sistema (taxa comissão, whatsapp, email, etc)
--    5. financial_ledger - Livro-razão financeiro de liquidações e resets
--
-- ✨ NOVAS POLÍTICAS RLS:
--    - Todos podem ler banners, FAQ e About (público)
--    - Só admin pode editar estas tabelas
--    - financial_ledger visível e inserível apenas por admin
--
-- ✨ DADOS INICIAIS:
--    - 8 FAQs pré-preenchidas em português
--    - 6 informações sobre nós (missão, inovação, 4 valores)
--    - 10 configuracoes do sistema padrao (inclui textos legais e ciclo financeiro)
--    - 2 banners de exemplo
--
-- ✨ FINANCEIRO v1.6:
--    - Hardening idempotente de commission_amount/commission_status/commission_paid_amount
--    - Constraints de integridade (status valido, valores nao-negativos, paid <= amount)
--    - Liquidação transacional por período via RPC: apply_commission_payment_by_period_admin
--    - Reset de dívida com trilha de auditoria via RPC: reset_commission_debt_admin
--    - Normalizacao de status robusta (sem dependencia de extensao): normalize_order_status/is_order_completed
--    - Função utilitária de período: get_period_range
--    - Locks com FOR UPDATE SKIP LOCKED para reduzir contenção concorrente
--    - Índices parciais para consultas de pendência/comissão por farmácia e período
--    - Proteção de campos financeiros em orders para não-admin
--
-- 📌 INSTRUÇÕES PARA DEPLOY:
--    1. Copiar todo este SQL para o editor do Supabase (SQL Editor)
--    2. Executar todo o script
--    3. Verificar se todas as tabelas foram criadas: admin_banners, admin_faq, admin_about, system_config
--    4. Confirmar que as políticas RLS estão ativas em cada tabela
--    5. No app, os dados aparecerão automaticamente nas abas de CONFIGURAÇÕES do Admin
-- ============================================================================



